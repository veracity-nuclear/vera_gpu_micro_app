# vera_gpu_micro_app

## Table of Contents
1. [Project Overview](#project-overview)
2. [Dependency Installation](#dependency-installation)
3. [Package Configuration and Build](#package-configuration-and-build)
4. [Developer Tools](#developer-tools)
5. [Micro Applications Data](#micro-applications-data)


## Project Overview
Contains micro-applications for prototyping of VERA GPU capabilities

Four micro-apps are defined in this repo, each with its own source
and test data:
1. MOC
2. CMFD
3. Conduction
4. Subchannel

Each of these focuses on a different computationally intensive portion
of the VERA solve.  Test data produced from VERA can be used to test
the accuracy and performance of the implementation.


## Dependency Installation
### Build essentials, CMake, OpenMP and HDF5 from apt package manager

1. Build packages
```bash
sudo apt-get update
sudo apt-get install -y \
    build-essential cmake git curl wget \
    gfortran libhdf5-dev libopenmpi-dev openmpi-bin
```

2. Export environment variables
You should export the HDF5 environment variable:
```
export HDF5_ROOT=/usr/bin
```

### Kokkos
1. Clone the Kokkos repository
```
git clone --branch develop https://github.com/kokkos/kokkos.git
```

2. Configure the build with CMake (may need to sudo for access to /opt directory)
```
cmake -B kokkos/build \
  -DKokkos_ENABLE_SERIAL=ON \
  -DKokkos_ENABLE_OPENMP=ON \
  -DKokkos_ENABLE_INSTALL=ON \
  -DCMAKE_INSTALL_PREFIX=/opt/kokkos \
  kokkos
```
Optionally, add the `-DKokkos_ENABLE_CUDA=ON` to build with CUDA support.

3. Build Kokkos (any number of processors can be used)
```
cmake --build kokkos/build --parallel 6
```

4. Install Kokkos
```
cmake --install kokkos/build
```

5. Cleanup (optional)
```
rm -rf kokkos
```

6. Export environment variables
```
export KOKKOS_ROOT=/opt/kokkos
```

### PETSc
1. Set environment variables
```
export PETSC_DIR=/opt/petsc
export PETSC_ARCH=arch-linux-opt
```

2. Clone the PETSc repository (may need to sudo for access to /opt directory)
```
git clone -b release https://gitlab.com/petsc/petsc.git $PETSC_DIR
cd $PETSC_DIR
```

3. Configure the build (this may take >30 min to complete)
```
./configure \
  --with-cc=mpicc \
  --with-cxx=mpicxx \
  --with-fc=0 \
  --with-debugging=0 \
  --with-rtlib=libc \
  --download-hwloc \
  --download-f2cblaslapack \
  --COPTFLAGS="-O3 -march=native" \
  --CXXOPTFLAGS="-O3 -march=native"
```

4. Build PETSc
```
make PETSC_DIR=$PETSC_DIR PETSC_ARCH=$PETSC_ARCH all
```

5. Confirm the installation
```
make PETSC_DIR=$PETSC_DIR PETSC_ARCH=$PETSC_ARCH check
```

### HighFive
1. Clone the HighFive repository
```
git clone --recursive --branch v2.9.0 https://github.com/BlueBrain/HighFive.git
```

2. Configure the build with CMake (may need to sudo for access to /opt directory)
```
cmake -B HighFive/build HighFive \
  -DCMAKE_INSTALL_PREFIX=/opt/highfive \
  -DHIGHFIVE_BUILD_DOCS=OFF \
  -DHIGHFIVE_BUILD_TESTS=OFF \
  -DHIGHFIVE_USE_BOOST=OFF
```

3. Build HighFive (any number of processors can be used)
```
cmake --build HighFive/build --parallel 6
```

4. Install HighFive
```
cmake --install HighFive/build
```

5. Cleanup (optional)
```
rm -rf HighFive
```

6. Export environment variables
```
export HIGHFIVE_ROOT=/opt/highfive
```


## Package Configuration and Build
Before building, you should `export` all the environment variables defined in the previous sections.

From `~/vera_gpu_micro_app` execute the following commands to configure and build the micro-apps.
```
mkdir -p build
cmake -B build -DCMAKE_C_COMPILER=mpicc -DCMAKE_CXX_COMPILER=mpicxx
cmake --build build -j4
```


## Developer Tools

### Testing the micro-apps
```
cd build
ctest -j4 --output-on-failure
```

### Running package executables
Execute these commands from the `~/vera_gpu_micro_app/build` directory to run micro-app executables. These can be renamed in
`~/vera_gpu_micro_apps/<micro-app>/CMakeLists.txt` as well.

```
# MOC
./moc/micro_moc

# CMFD
./cmfd/cmfd_exec

# Conduction
./conduction/conduction_exec

# Subchannel
./subchannel/subchannel_exec
```

## Micro Applications Data

Each micro application has its own data directory containing input and output files.
These input files are run in VERA to generate the output files, which are then used to test the micro-apps.
Each micro app uses different data.  The data for each micro app is described below.
Because the data is generated by Fortran-based VERA, any indexing in the data is Fortran-style (1-based).

### MOC

| Dataset Name | Type | Shape | Description |
| ------------ | ---- | ----- | ----------- |
| `Azimuthal Radians` | `float` | (n_azimuthal) | The azimuthal angles in radians. |
| `Polar Radians` | `float` | (n_polar) | The polar angles in radians. |
| `Azimuthal Weights` | `float` | (n_azimuthal) | The weights for each azimuthal angle. |
| `Polar Weights` | `float` | (n_polar) | The weights for each polar angle. |
| `Domain_#####` | HDF5 group | - | Each group contains data for a specific spatial domain. The group name is the domain ID, which is a 5-digit number with leading zeros (e.g., `00001`, `00002`, etc.). |
| `Domain_#####/FSR_Volume` | `float` | (n_fsrs) | The volume of each FSR in the domain. |
| `Domain_#####/Starting XSR` | `int` | scalar | The starting XSR index for the domain. |
| `Domain_#####/XSRtoFSR_Map` | `int` | (n_xsrs) | The mapping from XSRs to FSRs in the domain. Each value is the first FSR index corresponding to the XSR index. |
| `Domain_#####/XSR_Volume` | `float` | (n_xsrs) | The volume of each XSR in the domain. |
| `Domain_#####/Solution_Data/fsr_flux` | `float` | (n_groups, n_fsrs) | The flux in each FSR for each energy group. |
| `Domain_#####/Solution_Data/xsr_mat_id` | `int` | (n_xsrs) | The material ID for each XSR in the domain. |
| `Domain_#####/Solution_Data/xsr_temp` | `float` | (n_xsrs) | The temperature for each XSR in the domain. |
| `Domain_#####/Angle_####` | HDF5 group | - | Each group contains data for a specific angle. The group name is the angle ID, which is a 4-digit number with leading zeros (e.g., `0001`, `0002`, etc.). |
| `Domain_#####/Angle_####/Radians` | `float` | scalar | The angle in radians. |
| `Domain_#####/Angle_####/spacing` | `float` | scalar | The angle-dependent ray-spacing for the angle. |
| `Domain_#####/Angle_####/LongRay_######` | HDF5 group | - | Each group contains data for a specific long ray. The group name is the long ray ID, which is a 6-digit number with leading zeros (e.g., `000001`, `000002`, etc.). |
| `Domain_#####/Angle_####/LongRay_######/BC_face` | `int` | (2) | The face indexes for the long ray boundary condition; `BC_face[0]` is the start of the ray and `BC_face[1]` is the end of the ray; the face indexes are 1-based: (1: west, 2: north, 3: east, 4: south, 5: top, 6: bottom). |
| `Domain_#####/Angle_####/LongRay_######/BC_index` | `int` | (2) | The boundary condition indexes for the long ray; `BC_index[0]` is the start of the ray and `BC_index[1]` is the end of the ray; the index corresponds to the position in the ray for the face specified by `BC_face`. |
| `Domain_#####/Angle_####/LongRay_######/FSRs` | `int` | (n_fsrs) | The FSR indexes for the long ray; the FSRs are in the order they are encountered along the ray. |
| `Domain_#####/Angle_####/LongRay_######/Segments` | `float` | (n_segments) | The segment lengths for the long ray; the segments are in the order they are encountered along the ray. |
| `Domain_#####/Angle_####/LongRay_######/Starting_Point` | `float` | (3) | The starting point of the long ray in Cartesian coordinates (x, y, z). |

### CMFD

There are 3 possible directories in the HDF5 file to support micro CMFD.  Each of these is
discussed below in its own section.

#### CMFD_Matrix

| Dataset Name | Type | Shape | Description |
| ------------ | ---- | ----- | ----------- |
| `A` | HDF5 group | - | Each dataset inside this group is a row in the CMFD matrix.  The datasets are named from 1 to `N`, using 9 digits with leading zeros (e.g., `000000001`, `000000002`, etc.).  There are `N` values in each dataset. |
| `b` | `float` | (n_cells) | The right-hand side vector for the CMFD matrix equation. |
| `x` | `float` | (n_cells) | The solution vector for the CMFD matrix equation. |

#### CMFD_CoarseMesh

The following data is used for micro CMFD to build its own CMFD matrix from coarse mesh cross sections.
These datasets are inside `/CMFD_CoarseMesh` in the HDF5 file.

| Dataset Name | Type | Shape | Description |
| ------------ | ---- | ----- | ----------- |
| `first cell` | `int` | scalar | The first cell in the coarse mesh. |
| `last cell` | `int` | scalar | The last cell in the coarse mesh. |
| `energy groups` | `int` | scalar | The number of energy groups in the coarse mesh. |
| `volume` | `float` | (n_cells) | The volume of each coarse mesh cell. |
| `flux` | `float` | (n_groups, n_cells) | The flux in each coarse mesh cell for each energy group. |
| `transport XS` | `float` | (n_groups, n_cells) | The transport cross section in each coarse mesh cell for each energy group. |
| `removal XS` | `float` | (n_groups, n_cells) | The removal cross section in each coarse mesh cell for each energy group. |
| `nu-fission XS` | `float` | (n_groups, n_cells) | The nu-fission cross section in each coarse mesh cell for each energy group. |
| `scattering XS` | group | n/a | The scattering cross section in each coarse mesh cell for each energy group. |
| `chi` | `float` | (n_groups, n_cells) | The chi in each coarse mesh cell for each energy group. |
| `surf2cell` | `int` | (n_surf, 2) | The surface to cell mapping for each coarse mesh cell; the first column is the cell index on the positive side (north, east, up) and the second column is the cell index on the negative side (south, west, down). |
| `Dtilde` | `float` | (n_groups, n_surf) | The $`\tilde{D}`$ value multiplied by surface area for each surface in each energy group. |
| `Dhat` | `float` | (n_groups, n_surf) | The $`\hat{D}`$ value multiplied by surface area for each surface in each energy group. |

See "Scattering Matrix Storage" below for details on the `scattering XS` group.

#### CMFD_FineMesh

The following data is used for micro CMFD to homogenize its own coarse mesh cross sections.
These datasets are inside `/CMFD_FineMesh` in the HDF5 file.

| Dataset Name | Type | Shape | Description |
| ------------ | ---- | ----- | ----------- |
| `nxscells` | `int` | (n_coarse_cells) | The number of XS regions in each coarse mesh cell. |
| `nfinecells` | `int` | (n_xsregions) | The number of fine mesh cells in each XS region. |
| `isFissionable` | `bool` | (n_xsregions) | Indicates if each XS region is fissionable (True) or not (False) |
| `volume` | `float` | (n_xsregions) | The volume of each XS region. |
| `flux` | `float` | (n_groups, n_fineregions) | The flux in each fine mesh cell for each energy group. |
| `transport XS` | `float` | (n_xsregions, n_groups) | The transport cross section for each fine mesh cell in each XS region. |
| `total XS` | `float` | (n_xsregions, n_groups) | The total cross section for each fine mesh cell in each XS region. |
| `nu-fission XS` | `float` | (n_fissionable, n_groups) | The nu-fission cross section for each fine mesh cell in each XS region. |
| `scattering XS` | group | n/a | The scattering cross section for each fine mesh cell in each XS region. |
| `chi` | `float` | (n_fissionable, n_groups) | The chi for each fine mesh cell in each XS region. |

For a single pin cell problem with 4 regions (coolant, clad, gap, fuel), each divided into 8 azimuthal regions, `nxscells` will be `[0, 4]`, `nfinecells` will be `[0, 8, 16, 24, 32]` and `isFissionable` will be `[F, F, F, T]`.
The `volume` array will have 4 values (one per XS region); the fine mesh volume for each region will be the XS region volume divided by the number of fine mesh cells in that region (8 in this example).
The transport, total, and scattering cross sections are defined for every XS region.
The nu-fission cross section and chi are only defined for fissionable regions.
The removal cross section is calculated by homogenizing the total & scattering cross sections, then subtracting the homogenized self-scatter from the homogenized total XS.

See "Scattering Matrix Storage" below for details on the `scattering XS` group.

#### Scattering Matrix Storage

The `scattering XS` group contains datasets for each coarse, simply named with the region index formatted to 9 digits (e.g., `000000001`, `000000002`, etc.).
Inside each cell's group, there is `gMin`, `gMax`, and `xssc` datasets.
`gMin` and `gMax` are the length of the number of groups.
The `g`-th index of `gMin` gives the first group `g'` from which scattering occurs into `g`; similarly, the `g`-th index of `gMax` gives the last group `g''` from which scattering occurs into `g`.
The `xssc` dataset is the 1D array of non-zero values; its length is equal to the sum of the differences between `gMax` and `gMin` for each group.

### Conduction

This data is not yet implemented.

### Subchannel

This data is not yet implemented.